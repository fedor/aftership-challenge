// Generated by CoffeeScript 1.7.1
(function() {
  var Beanworker, Courier, MongoClient, beans_tools, calls_per_sec, config, crypto, fivebeans, logger, max_calls_number, redis, worker_id;

  fivebeans = require('fivebeans');

  Beanworker = require('fivebeans').worker;

  redis = require('redis');

  logger = require('winston');

  beans_tools = require('./beans_tools');

  Courier = require('../couriers/index');

  MongoClient = require('mongodb').MongoClient;

  crypto = require('crypto');

  worker_id = crypto.createHash('md5').update(new Date().getTime().toString()).digest('hex');

  config = {
    "id": "worker_" + worker_id,
    "host": "127.0.0.1",
    "port": 11300,
    "tubes": ["requests_flow", "wait_list"],
    "ignoreDefault": true
  };

  calls_per_sec = 2;

  max_calls_number = 20;

  logger.remove(logger.transports.Console);

  logger.add(logger.transports.Console, {
    'timestamp': true
  });

  MongoClient.connect('mongodb://127.0.0.1:27017/bucket', function(err, db) {
    var beans_client, redis_client;
    beans_client = new fivebeans.client();
    redis_client = redis.createClient();
    beans_client.on('connect', function() {
      var RequestsFlowHandler, WaitListHandler, add_request_to_waiting_line, courier_callback, error_callback, get_wait_request, int_from_redis, start_time, worker;
      RequestsFlowHandler = function() {
        return this.type = 'requests_flow';
      };
      WaitListHandler = function() {
        return this.type = 'wait_list';
      };
      start_time = function(payload) {
        var start_time_;
        start_time_ = new Date().getTime();
        logger.info("\t---> getting tracking of " + payload.slug + " - " + payload.number + " (" + start_time_ + ")");
        return start_time_;
      };
      get_wait_request = function(slug) {
        return function() {
          return redis_client.get("calls_number:" + slug, function(err, calls_number) {
            var error;
            if (err) {
              return error_callback(err, "redis error", function() {});
            }
            try {
              calls_number = int_from_redis(calls_number);
              if (calls_number >= max_calls_number) {
                logger.info("\tscheduled call from wait_list:" + slug + " cancelled, " + calls_number + " appears at the moment");
                return;
              }
              return redis_client.lpop("wait_list:" + slug, function(err, number) {
                var redis_multi;
                if (err) {
                  return error_callback(err, "redis error", function() {});
                }
                if (number === null) {
                  return;
                }
                redis_multi = redis_client.multi();
                redis_multi.incr("calls_number:" + slug);
                redis_multi.expire("calls_number:" + slug, 30);
                return redis_multi.exec(function(err, replies) {
                  var callback, error, payload, start_time_, stub_cb;
                  if (err) {
                    return error_callback(err, "redis error", function() {});
                  }
                  try {
                    calls_number = int_from_redis(replies[0]);
                    logger.info("\tactive calls number for " + slug + " increased to " + calls_number + " by wait_list");
                    payload = {
                      slug: slug,
                      number: number
                    };
                    stub_cb = function() {};
                    start_time_ = start_time(payload);
                    callback = courier_callback(stub_cb, payload, start_time_);
                    return Courier[slug](number, callback);
                  } catch (_error) {
                    error = _error;
                    return error_callback(error, "get_wait_request (wait handler callback) error", function() {});
                  }
                });
              });
            } catch (_error) {
              error = _error;
              return error_callback(error, "get_wait_request (wait handler callback) error", function() {});
            }
          });
        };
      };
      error_callback = function(error, message, callback) {
        logger.error("" + message + ": " + error);
        return callback('error');
      };
      WaitListHandler.prototype.work = function(payload, callback) {
        var redis_multi, slug;
        logger.info("job recieved to wait_list, payload: " + (JSON.stringify(payload)));
        slug = payload.slug;
        logger.info("\tchecking if wait_list:" + slug + " needs handling...");
        redis_multi = redis_client.multi();
        redis_multi.incr("wait_list_activated:" + slug);
        redis_multi.llen("wait_list:" + slug);
        return redis_multi.exec(function(err, replies) {
          var activated, call, error, len, sec, seconds, _i, _j;
          if (err) {
            return error_callback(err, "redis error", callback);
          }
          try {
            activated = int_from_redis(replies[0]);
            len = int_from_redis(replies[1]);
            if (activated > 1 && len > 0) {
              logger.info("\twait_list:" + slug + " is handling is already in process, abort");
              return callback('success');
            }
            if (len < 1) {
              redis_client.del("wait_list_activated:" + slug);
              logger.info("\twait_list:" + slug + " appears to be empty, abort");
              return callback('success');
            }
            seconds = Math.ceil(len / calls_per_sec);
            logger.info("\twait_list:" + slug + " is now handled by this worker, scheduling calls for " + seconds + "s.");
            for (sec = _i = 1; 1 <= seconds ? _i <= seconds : _i >= seconds; sec = 1 <= seconds ? ++_i : --_i) {
              for (call = _j = 1; 1 <= calls_per_sec ? _j <= calls_per_sec : _j >= calls_per_sec; call = 1 <= calls_per_sec ? ++_j : --_j) {
                setTimeout(get_wait_request(slug), sec * 1000);
              }
            }
            return redis_client.expire("wait_list_activated:" + slug, seconds + 1, function(err, reply) {
              beans_tools.put_wrap(beans_client, 'wait_list', 0, seconds, 10, payload, 'wait_list');
              return callback('success');
            });
          } catch (_error) {
            error = _error;
            redis_client.del("wait_list_activated:" + slug);
            return error_callback(error, "issue in wait list handler", callback);
          }
        });
      };
      add_request_to_waiting_line = function(payload) {
        return redis_client.rpush("wait_list:" + payload.slug, payload.number, function(err, reply) {
          logger.info("\tjob w/ payload: " + (JSON.stringify(payload)) + " added to wait_list:" + payload.slug);
          return beans_tools.put_wrap(beans_client, 'wait_list', 0, 0, 10, {
            slug: payload.slug
          }, 'requests_flow');
        });
      };
      courier_callback = function(bean_callback, payload, start_time) {
        return function(err, tracking) {
          var checkpoints, delivered, delta_time, error, last_country, last_message, last_point, number, slug;
          try {
            slug = payload.slug;
            number = payload.number;
            redis_client.decr("calls_number:" + slug, function(err, calls_number) {
              if (err) {
                return error_callback(err, "redis error", bean_callback);
              }
              return logger.info("\tactive calls number for " + slug + " decreased to " + calls_number);
            });
            if (err) {
              return error_callback(err, "issue in courier callback", bean_callback);
            }
            checkpoints = tracking.checkpoints;
            last_point = checkpoints[checkpoints.length - 1];
            last_country = last_point.country_name.toLowerCase();
            last_message = last_point.message.toLowerCase();
            if (last_message.indexOf("delivered") > -1) {
              delivered = true;
            } else if (slug === "hkpost" && last_country !== "hong kong" && last_message.indexOf("left hong kong") > -1) {
              delivered = true;
            } else {
              delivered = false;
            }
            if (delivered) {
              tracking.slug = slug;
              tracking.tracking_number = number;
              db.collection('tracking').insert(tracking, function(err, docs) {
                var delta_time;
                if (err) {
                  return error_callback(err, "insertion to Mongo DB failed", bean_callback);
                }
                delta_time = new Date().getTime() - start_time;
                return logger.info("\t<--- " + slug + " - " + number + " delivered and saved to mongo, took " + delta_time + " ms. (" + start_time + ")");
              });
            } else {
              beans_tools.put_wrap(beans_client, 'requests_flow', 0, 3600 * 3, 60, payload, 'requests_flow');
              delta_time = new Date().getTime() - start_time;
              logger.info("\t<--- " + slug + " - " + number + " is not delivered yet, took " + delta_time + " ms. (" + start_time + ")");
            }
            return bean_callback('success');
          } catch (_error) {
            error = _error;
            return error_callback(error, "issue on handling courier callback data", bean_callback);
          }
        };
      };
      int_from_redis = function(reply) {
        if (reply === null) {
          return 0;
        } else {
          return reply;
        }
      };
      RequestsFlowHandler.prototype.work = function(payload, callback) {
        var error, redis_multi, slug;
        try {
          logger.info("job recieved to requests_flow, payload: " + (JSON.stringify(payload)));
          slug = payload.slug;
          redis_multi = redis_client.multi();
          redis_multi.llen("wait_list:" + slug);
          redis_multi.get("calls_number:" + slug);
          redis_multi.get("sec_calls:" + slug);
          return redis_multi.exec(function(err, replies) {
            var calls_number, error, sec_calls, wait_count;
            if (err) {
              return error_callback(err, "redis error", callback);
            }
            try {
              wait_count = int_from_redis(replies[0]);
              calls_number = int_from_redis(replies[1]);
              sec_calls = int_from_redis(replies[2]);
              if (wait_count > 0 || calls_number >= max_calls_number || sec_calls >= calls_per_sec) {
                add_request_to_waiting_line(payload);
                return callback('success');
              }
              redis_multi = redis_client.multi();
              redis_multi.llen("wait_list:" + slug);
              redis_multi.incr("calls_number:" + slug);
              redis_multi.incr("sec_calls:" + slug);
              redis_multi.expire("calls_number:" + slug, 30);
              if (sec_calls === 0) {
                redis_multi.expire("sec_calls:" + slug, 1);
              }
              return redis_multi.exec(function(err, replies) {
                var error, stub_cb;
                if (err) {
                  return error_callback(err, "redis error", callback);
                }
                try {
                  wait_count = int_from_redis(replies[0]);
                  calls_number = int_from_redis(replies[1]);
                  sec_calls = int_from_redis(replies[2]);
                  logger.info("\tactive calls number for " + slug + " increased to " + calls_number);
                  if (wait_count > 0 || calls_number > max_calls_number || sec_calls > calls_per_sec) {
                    redis_multi.decr("calls_number:" + slug);
                    redis_multi.decr("sec_calls:" + slug);
                    redis_multi.exec(function(err, replies) {
                      if (err) {
                        return error_callback(err, "redis error", callback);
                      }
                      add_request_to_waiting_line(payload);
                      return callback('success');
                    });
                    return;
                  }
                  stub_cb = function() {};
                  Courier[slug](payload.number, courier_callback(stub_cb, payload, start_time(payload)));
                  return callback('success');
                } catch (_error) {
                  error = _error;
                  return error_callback(error, "issue on handling requests_flow tube", callback);
                }
              });
            } catch (_error) {
              error = _error;
              return error_callback(error, "issue on handling requests_flow tube", callback);
            }
          });
        } catch (_error) {
          error = _error;
          return error_callback(error, "issue on handling requests_flow tube", callback);
        }
      };
      config.handlers = {
        requests_flow: new RequestsFlowHandler(),
        wait_list: new WaitListHandler()
      };
      worker = new Beanworker(config);
      return worker.start(config.tubes);
    });
    return beans_client.connect();
  });

}).call(this);
