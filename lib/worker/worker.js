// Generated by CoffeeScript 1.7.1
(function() {
  var Beanworker, Courier, MongoClient, beans_tools, calls_per_sec, config, crypto, fivebeans, logger, max_calls_number, redis, worker_id;

  fivebeans = require('fivebeans');

  Beanworker = require('fivebeans').worker;

  redis = require('redis');

  logger = require('winston');

  beans_tools = require('./beans_tools');

  Courier = require('../couriers/index');

  MongoClient = require('mongodb').MongoClient;

  crypto = require('crypto');

  worker_id = crypto.createHash('md5').update(new Date().getTime().toString()).digest('hex');

  config = {
    "id": "worker_" + worker_id,
    "host": "127.0.0.1",
    "port": 11300,
    "tubes": ["requests_flow", "wait_list"],
    "ignoreDefault": true
  };

  calls_per_sec = 2;

  max_calls_number = 20;

  logger.remove(logger.transports.Console);

  logger.add(logger.transports.Console, {
    'timestamp': true
  });

  MongoClient.connect('mongodb://127.0.0.1:27017/bucket', function(err, db) {
    var beans_client, redis_client;
    beans_client = new fivebeans.client();
    redis_client = redis.createClient();
    beans_client.on('connect', function() {
      var RequestsFlowHandler, WaitListHandler, add_request_to_waiting_line, courier_callback, get_wait_request, worker;
      RequestsFlowHandler = function() {
        return this.type = 'requests_flow';
      };
      WaitListHandler = function() {
        return this.type = 'wait_list';
      };
      get_wait_request = function(slug) {
        return function() {
          return redis_client.get("calls_number:" + slug, function(calls_number, err) {
            if (calls_number >= max_calls_number) {
              return;
            }
            return redis_client.lpop("wait_list:" + slug, function(number, err) {
              var start_time;
              if (number === null) {
                return;
              }
              start_time = new Date().getTime();
              logger.info("Getting tracking of " + slug + " - " + number + " (" + start_time + "), wait line");
              return Courier[slug](tracking_number, courier_callback(callback, {
                slug: slug,
                number: number
              }, start_time));
            });
          });
        };
      };
      WaitListHandler.prototype.work = function(payload, callback) {
        var slug;
        slug = payload.slug;
        redis_client.watch("wait_list_activated:" + slug);
        return redis_client.exists("wait_list_activated:" + slug, function(err, reply) {
          var redis_multi;
          if (reply === 1) {
            return callback('success');
          }
          redis_multi = redis_client.multi();
          redis_multi.set("wait_list_activated:" + slug, 1, 10);
          redis_multi.llen("wait_list:" + slug);
          return redis_multi.exec(function(err, replies) {
            var call, len, sec, seconds, _i, _j;
            if (err === null && replies === null) {
              return callback('success');
            }
            len = parseInt(replies[1]);
            seconds = Math.ceil(len / calls_per_sec);
            for (sec = _i = 1; 1 <= seconds ? _i <= seconds : _i >= seconds; sec = 1 <= seconds ? ++_i : --_i) {
              for (call = _j = 1; 1 <= calls_per_sec ? _j <= calls_per_sec : _j >= calls_per_sec; call = 1 <= calls_per_sec ? ++_j : --_j) {
                setTimeout(get_wait_request(slug), sec * 1000);
              }
            }
            return redis_client.expire("wait_list_activated:" + slug, seconds, function(err, reply) {
              beans_tools.put_wrap(beans_client, 'wait_list', 0, seconds, 10, payload);
              return callback('success');
            });
          });
        });
      };
      add_request_to_waiting_line = function(payload) {
        return redis_client.rpush("wait_list:" + payload.slug, payload.number, function(err, reply) {
          return beans_tools.put_wrap(beans_client, 'wait_list', 0, 0, 10, {
            slug: payload.slug
          });
        });
      };
      courier_callback = function(bean_callback, payload, start_time) {
        return function(err, tracking) {
          var checkpoints, delivered, error, last_country, last_message, last_point, number, slug;
          try {
            redis_client.decr("calls_number:" + slug);
            if (err) {
              logger.error("issue in courier callback: " + err);
              return bean_callback('error');
            }
            slug = payload.slug;
            number = payload.number;
            checkpoints = tracking.checkpoints;
            last_point = checkpoints[checkpoints.length - 1];
            last_country = last_point.country_name.toLowerCase();
            last_message = last_point.message.toLowerCase();
            if (last_message.indexOf("delivered") > -1) {
              delivered = true;
            } else if (slug === "hkpost" && last_country !== "hong kong" && last_message.indexOf("left hong kong") > -1) {
              delivered = true;
            } else {
              delivered = false;
            }
            if (delivered) {
              tracking.slug = slug;
              tracking.tracking_number = number;
              db.collection('tracking').insert(tracking, function(err, docs) {
                var delta_time;
                if (err) {
                  logger.error("insertion to Mongo DB failed: " + err);
                  return bean_callback('error');
                }
                delta_time = new Date().getTime() - start_time;
                return logger.info("" + slug + " - " + number + " delivered and saved to mongo,took " + delta_time + " ms. (" + start_time + ")");
              });
            } else {
              beans_tools.put_wrap(beans_client, 'requests_flow', 0, 3600 * 3, 60, payload);
              logger.info("" + slug + " - " + number + " is not delivered yet,took " + delta_time + " ms. (" + start_time + ")");
            }
            return bean_callback('success');
          } catch (_error) {
            error = _error;
            logger.error("issue on handling courier callback data: " + error);
            return bean_callback('error');
          }
        };
      };
      RequestsFlowHandler.prototype.work = function(payload, callback) {
        var error, redis_multi, slug;
        try {
          logger.info("Job recieved, payload: " + (JSON.stringify(payload)));
          slug = payload.slug;
          redis_multi = redis_client.multi();
          redis_multi.llen("wait_list:" + slug);
          redis_multi.get("calls_number:" + slug);
          redis_multi.get("sec_calls:" + slug);
          return redis_multi.exec(function(err, replies) {
            var calls_number, sec_calls, wait_count;
            wait_count = parseInt(replies[0]);
            calls_number = replies[1] === null ? 0 : parseInt(replies[1]);
            sec_calls = replies[2] === null ? 0 : parseInt(replies[2]);
            if (wait_count > 0 || calls_number >= max_calls_number || sec_calls >= calls_per_sec) {
              add_request_to_waiting_line(payload);
              return callback('success');
            }
            redis_multi = redis_client.multi();
            redis_multi.incr("calls_number:" + slug);
            redis_multi.expire("calls_number:" + slug, 60);
            redis_multi.incr("sec_calls:" + slug);
            if (sec_calls === 0) {
              redis_multi.expire("sec_calls:" + slug, 1);
            }
            return redis_multi.exec(function(err, replies) {
              var start_time;
              if (err) {
                throw err;
              }
              try {
                calls_number = replies[0] === null ? 0 : parseInt(replies[0]);
                sec_calls = replies[1] === null ? 0 : parseInt(replies[1]);
                if (calls_number > max_calls_number || sec_calls > calls_per_sec) {
                  beans_tools.put_wrap(beans_client, 'requests_flow', 0, 1, 60, payload);
                  redis_client.decr("calls_number:" + slug);
                  return callback('success');
                }
                start_time = new Date().getTime();
                logger.info("Getting tracking of " + slug + " - " + payload.number + " (" + start_time + ")");
                return Courier[slug](payload.number, courier_callback(callback, payload, start_time));
              } catch (_error) {
                redis_client.decr("calls_number:" + slug);
                return beans_tools.put_wrap(beans_client, 'requests_flow', 0, 1, 60, payload);
              }
            });
          });
        } catch (_error) {
          error = _error;
          logger.error("Issue on handling requests_flow tube: " + error);
          return callback('error');
        }
      };
      config.handlers = {
        requests_flow: new RequestsFlowHandler(),
        wait_list: new WaitListHandler()
      };
      worker = new Beanworker(config);
      return worker.start(config.tubes);
    });
    return beans_client.connect();
  });

}).call(this);
