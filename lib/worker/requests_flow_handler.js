// Generated by CoffeeScript 1.7.1
(function() {
  var Beanworker, Courier, MongoClient, beans_tools, calls_per_sec, config, fivebeans, logger, max_calls_number, redis;

  fivebeans = require('fivebeans');

  Beanworker = require('fivebeans').worker;

  config = require('./config.json');

  redis = require('redis');

  logger = require('winston');

  beans_tools = require('./beans_tools');

  Courier = require('../couriers/index');

  MongoClient = require('mongodb').MongoClient;

  calls_per_sec = 2;

  max_calls_number = 20;

  logger.remove(logger.transports.Console);

  logger.add(logger.transports.Console, {
    'timestamp': true
  });

  MongoClient.connect('mongodb://127.0.0.1:27017/bucket', function(err, db) {
    var RequestsFlowHandler, beans_client, redis_client, worker;
    beans_client = new fivebeans.client();
    redis_client = redis.createClient();
    RequestsFlowHandler = function() {
      return this.type = 'requests_flow';
    };
    RequestsFlowHandler.prototype.work = function(payload, callback) {
      var redis_multi, slug;
      logger.info("Job recieved, payload: " + (JSON.stringify(payload)));
      slug = payload.slug;
      redis_multi = redis_client.multi();
      redis_multi.get("calls_number:" + slug);
      redis_multi.get("last_sec_calls:" + slug);
      return redis_multi.exec(function(err, replies) {
        var calls_number, last_sec_calls;
        calls_number = replies[0] === null ? 0 : parseInt(replies[0]);
        last_sec_calls = replies[1] === null ? 0 : parseInt(replies[1]);
        if (calls_number >= max_calls_number || last_sec_calls >= calls_per_sec) {
          add_request_to_waiting_line(payload);
          return callback('success');
        }
        redis_multi = redis_client.multi();
        redis_multi.incr("calls_number:" + slug);
        redis_multi.incr("last_sec_calls:" + slug);
        return redis_multi.exec(function(err, replies) {
          var start_time, tracking_number;
          calls_number = replies[0] === null ? 0 : parseInt(replies[0]);
          last_sec_calls = replies[1] === null ? 0 : parseInt(replies[1]);
          if (calls_number > max_calls_number || last_sec_calls > calls_per_sec) {
            beans_tools.put_wrap(beans_client, 'requests_flow', 0, 1, 60, payload);
            return redis_client.decr("calls_number:" + slug, function(err, reply) {
              return callback('success');
            });
          }
          start_time = new Date().getTime();
          tracking_number = payload.number;
          logger.info("Getting tracking of " + slug + " - " + tracking_number + " (" + start_time + ")");
          return Courier[slug](tracking_number, function(err, tracking) {
            var delivered, last_dst, last_msg;
            last_msg = tracking.checkpoints[tracking.checkpoints.length - 1].message.lower();
            delivered = false;
            if (last_msg.indexOf("delivered") > -1) {
              delivered = true;
            } else if (slug === "hkpost") {
              last_dst = tracking.checkpoints[tracking.checkpoints.length - 1].country_name;
              if (last_msg.indexOf("left hong kong") > -1 && last_dst !== "Hong Kong") {
                delivered = true;
              }
            }
            if (delivered) {
              tracking.slug = slug;
              tracking.tracking_number = tracking_number;
              db.collection('tracking').insert(tracking, function(err, docs) {
                var delta_time;
                delta_time = new Date().getTime() - start_time;
                return logger.info("" + slug + " - " + tracking_number + " delivered and saved to mongo,took " + delta_time + " ms. (" + start_time + ")");
              });
            } else {
              beans_tools.put_wrap(beans_client, 'requests_flow', 0, 3600 * 3, 60, payload);
              logger.info("" + slug + " - " + tracking_number + " is not delivered yet,took " + delta_time + " ms. (" + start_time + ")");
            }
            return callback('success');
          });
        });
      });
    };
    config.handlers = {
      requests_flow: new RequestsFlowHandler()
    };
    worker = new Beanworker(config);
    return worker.start(config.tubes);
  });

}).call(this);
